<meta charset="utf8">
ООП в PHP: изучаем на реальных примерах

Лично мне очень нравится ООП в PHP, и возможности, которые оно дает для создания продукта, достаточно велики. Большинство вакансий PHP - разработчика включает в себя требования к владению ООП в разработке. Вы не сможете написать что-то вразумительное на современных PHP фреймворках, таких как Laravel, Symfony, или на таком популярном, как 1C Bitrix, если не владеете хотя бы основами ООП. В интернете существует множество гайдов, что такое ООП, есть некоторые недурные <a href="https://books.google.ru/books/about/%D0%9F%D1%80%D0%B8%D0%B5%D0%BC%D1%8B_%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE_%D0%BE%D1%80%D0%B8%D0%B5%D0%BD.html?id=D_TDCwAAQBAJ&printsec=frontcover&source=kp_read_button&redir_esc=y#v=onepage&q&f=false">книги</a> , и чуть меньше именно по ООП в  <a href="http://www.dialektika.com/books/978-5-8459-1689-1.html">PHP</a>. В последнее время я перевернул интернет в поисках примеров для студентов, и не нашел практически ничего свеженького, что могло бы быть реально полезно. Сегодня я хочу немного изменить эту игру, и посмотреть на теорию паралелльно с реально работающими примерами. Конечно, идеального кода я сегодня на напишу, оно и понятно - реально большие PHP ООП проекты очень большие, поэтому по возможности я буду приводить компактные примеры.
<cut />

<h3> Вступление </h3>
Несмотря на большое количество гайдов по ООП, в которых авторы не привязываются конкретно ни к какому языку, сама реализация объектов и классов, а главное, синтаксические возможности языков разительно различаются. Если современное ООП в JavaScript у разработчиков из статических языков вызывает только раздражение (цитата моего знакого Java - разработчика "из JavaScript мне нравится только TypeScript, но он потом все равно компилируется в JavaScript, поэтому он мне не нравится"), и дело не только в динамической типизации, но и развитии ООП, но с другой стороны ничего нелогично здесь нет - JavaScript  это полноценный, но скриптовый язык программирования, который в итоге через развитие интернета и разрося до неимоверных размеров. Но сейчас речь не о JavaScript или Java, сейчас речь о языке, который находится в своем положении где-то посередине - PHP.

<h5> Зачем там вообще в PHP ООП </h5>
До какого-то ключевого момента (примерно до 5 версии), в PHP не было полноценной поддержки ООП, хотя классы и объекты поддерживались уже с 3 версии. Конечно, в самом PHP заключаются некоторые фатальные недостатки, большинство из которых все еще остаются в языке даже в новейших версиях (полный список, если вы еще их не читали, можно почитать в этой  <a href="http://eqsash.com/articles/ustroystvo-yazyka-php-ego-plyusy-i-minusy">  статейке</a>). Но непонятных статей на темы "ООП в PHP другое, и это хорошо",  "не трогайте OOП в PHP, и вас ждет успех" и так далее много, так что давайте теперь перейдем к самому синтаксису в PHP.

<h4> Синтаксические возможности PHP в плане ООП </h4>
Если читатель хоть немного програмировал в PHP, он знает, что этот язык поддерживает сразу две парадигмы, функциональную и объектно-ориентированную. Это двойственность языка вроде как никого не смущает, но часто приводит к проблемам в выполнении кода, потому как у множества функций есть двойственный интерфейс, к примеру mysqli:
<source lang='php'>
#процедурный вариант

$connect = mysqli_connect("localhost", "root", "password", "db_example");  
# не буду тут приводить обработку ошибок 

$res = mysqli_query($connect, "SELECT  * from users WHERE id = 1");
$row = mysqli_fetch_assoc($res);
echo $row['msg'];

#тот же самый код, только в объектно-ориентированном виде	
$mysqli = new connect("localhost", "root", "password", "db_example");
#обработка ошибок
$res = $mysqli->query("SELECT  * from users WHERE id = 1");
$row = $res->fetch_assoc();
echo $row['msg'];
</source>

Оба эти запроса к базе данных MySQL одинако успешно выведут нам колонку сообщений данные пользователя с id = 1. Правда, в документации рекомендуется использовать объектно-ориентированный вариант, но зачем же тогда существует процедурный?
Это был только один из примеров. Так какие ООП возможности PHP мы разберем сегодня:
<ul>
	<li>Конструктор, создание экземпляра из класса</li>	
	<li> Ключевое слово static</li>	
	<li> Наследование </li>	
</ul>


<h3> Классы и экземпляры </h3>
 Изучение объектно-ориентрированной парадигмы часто начинается с изучения экземпляров и классов. Учитывая, что концепция объектно-ориентированного программирования сама по себе пришла к нам из реального мира, здесь можно приводить множество аналогий, по типу абстрактный класс Автомобиль, экземпляр - "лада седан баклажан 2017 года выпуска".
 Что касается PHP, то в нем классическое решение относительно классов-> экземпляров, это перенести в класс какой-либо повторяющийся элемент, используя его как шаблон с повторяющимся контентов (ну и в общем примерно в таком же виде работает. Очень часто гайдах по ООП можно встретить пример с классом User, но сегодня я обращусь к примеру класса Post. Допустим, у вас какой-то элементарный новостной сайт, в котором можно есть простенькая админка, в которой можно выкладывать свои новости. Меня долго мучила причина, почему они называют именно "магическими", но вся магия состоит в том, что их не нужно вызывать и они "магически" вызываются при создании экземпляра.

 <source lang='PHP'>
class Post
{
    #просто предположим, что у нашего поста всего есть изображение
    public function __construct($id, $img, $header, $content)
    {
        $this->img = $img;
        $this->header = $header;
        $this->content = $content;
    }
    #здесь я делаю не совсем хорошую вещь, я отдаю представление вместо c html версткой. Но, положим, я не собираюсь развивать этот класс больше
    public function return_view()
    {
        return "
    <img  src=" . $this->img . " >
    <h3>" . $this->header . "</h3>
    <p>" . $this->content . "</p>";

    }
}

 </source>
ООП в PHP часто начинается изучатся с создания экземпляров объекта, и затем смены значения их полей, не вижу особого смысла в этом, я думаю стоит сразу начать писать классы с конструкторами. После того, как мы создали класс, мы можем его использовать, например в цикле:

<source>

require $_SERVER['DOCUMENT_ROOT'] . "/project_forum/classes/Card.class.php";

echo "<section>";
for ($i = 0; $i < count($post_data["header"]); $i++) {
    //здесь у нас цикл будет крутиться до той поры, пока есть заголовки
    // предполагается что постов без заголовков у нас нет
    $post = new Post($post_data[$img][$i], $post_data[$header][$i], $post_data[$content][$i]);
    echo "<div class='post_data'>";
    echo $post->return_view();
    //выводим наше представление
    echo "</div>";
}
echo " </section>";


</source>


 <h3> Ключевое слово static </h3>

В PHP объявление свойств или методов класса статическими дает возможность обращаться без инициализации экземпляра. В данном примере я создам класс работы с базой данных, которой дает возможность быстро подключаться к базе данных. Кроме того, особенность работы классов заключается в том, что вам не нужно реимпортировать классы каждый раз:
Наш файлы Db.class.php:
<source lang="php">

class Db
{
    public static function getdbconnect()
    {
        $connect = mysqli_connect("localhost", "root", "", "test_db") or die("Couldn't connect");
        $connect->set_charset("utf8");
        return $connect;
    }
}

</source>
После итого вы сможете после использовать этот класс прямо без создания экземпляра следующим образом:
<source lang="php">
class User
{
    public function login()
    {
        $this->user_name = trim($user_name);
        $this->user_password = hash('sha256', $user_password);
        $result = Db::getdbconnect()->query("SELECT * FROM users WHERE Name = '$this->user_name'");
    }
}


</source>



<h3> Наследование  </h3>

Чаще всего наследование подразумеват по собой использование уже имеющегося шаблона класса с целью его расширения. По сути это можно сравнить с комплектацией автомобилей в реальном мире: если вас интересует только базовая комплектация автомобиля и большего вам и не надо, тогда вы берете автомобиль с минимальным набором функций. Однако если вы много пользуетесь автомобилем и часто попадаете в различные ситуации, вам нужна расширенная функционнальность.
Что касаете PHP, то здесь есть даже абстрактные классы и функции, в которых описывать работы класса, однако от них даже нельзя создавать экземпляры. 
Но сейчас не об этом. Если мы говорим о наследовании, то достаточно часто оно используется для содания набора пользователей, которые посещают ваш сайт. Положим, у вас есть пользователи, которые могут комментировать сообщения на вашем блоге, и могут быть админы, которые тоже могут отвечать пользователям и комментировать. Таким образом, у нас получается следующая структура:
<source lang='php'>
class User
{
    # для примера возьму самый минималистичный вариант, которым можно обойтись в таких сервисах
    protected $user_email;
    protected $user_password;

    public function register($user_name, $user_password)
    {
        // пользователь может зарегестрироваться
    }

    public function login()
    {
        #пользователь может зайти на ресурс
    }

    public function logout($user_email, $user_password)
    {

    }

    public function сomment($user_email)
    {
        //  пользователь может оставлять комментарии в любом из постов
    }

}

</source>
Дальше, у нас есть дополнительный функционал у нашего класса Admin:
<source lang= "php">
class Admin extends User
{

    public function edit()
    {
        # удаляет комменты со страницы
    }
}

</source>
Отлично, теперь вы можете создавать два вида пользователей, и у каждого будет своя функциональность. Кроме того, никто не мешает вам потом создать, к примеру, суперадминстратора, который сможет добавлять/удалять админстраторов, когда ваш сайт увеличится в размерах и придется набирать достаточно большую команду админов.
На этом все. Вот некоторые полезные ссылки:
<ul>
	<li><a href="https://www.php.net/manual/ru/language.oop5.php"> Введение в PHP из официальной документации </a>
		<li>  <a href="https://www.codechief.org/article/class-abstraction-abstract-class-in-php.html">  Немного на абстрактном классе</a> </li>
		<li> <a href="https://habr.com/ru/post/302942/">Полезная информация по нововедениям PHP7, если вам не очень понятно, чем 7 версия языка отличается от 5</a></li>
</li>
</ul>


























